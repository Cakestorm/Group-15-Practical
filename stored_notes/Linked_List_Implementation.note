{"title": "Linked Lists for Disjoint Sets", "body": {"ops": [{"attributes": {"color": "#47a1b3", "underline": true}, "insert": "Linked Lists for Disjoint Sets"}, {"attributes": {"header": 2}, "insert": "\n"}, {"insert": "We might use a "}, {"attributes": {"color": "#47a1b3"}, "insert": "linked list"}, {"insert": " to implement a "}, {"attributes": {"link": "#Disjoint_Sets"}, "insert": "disjoint-set datastructure"}, {"insert": ". We represent each "}, {"attributes": {"color": "#98add9"}, "insert": "set "}, {"insert": "by a"}, {"attributes": {"color": "#47a1b3"}, "insert": " linked list"}, {"insert": ", and store those "}, {"attributes": {"color": "#47a1b3"}, "insert": "linked lists"}, {"insert": " in their own "}, {"attributes": {"color": "#47a1b3"}, "insert": "higher-level linked list"}, {"insert": ". We keep "}, {"attributes": {"color": "#50c75a"}, "insert": "pointers "}, {"insert": "to the first and last elements of the "}, {"attributes": {"color": "#47a1b3"}, "insert": "list"}, {"insert": ".\n\nWe implement the operations as follows:\n\nMake-Set("}, {"attributes": {"color": "#98add9"}, "insert": "x"}, {"insert": "): Append a singleton list "}, {"attributes": {"color": "#98add9"}, "insert": "x"}, {"insert": " to the "}, {"attributes": {"color": "#47a1b3"}, "insert": "main list"}, {"insert": ", and update "}, {"attributes": {"color": "#50c75a"}, "insert": "pointers"}, {"insert": ". "}, {"attributes": {"color": "#98add9"}, "insert": "O(1)"}, {"insert": "."}, {"attributes": {"list": "ordered"}, "insert": "\n"}, {"insert": "Find-Set("}, {"attributes": {"color": "#98add9"}, "insert": "x"}, {"insert": "): Follow the"}, {"attributes": {"color": "#50c75a"}, "insert": " head pointer"}, {"insert": " until reaching "}, {"attributes": {"color": "#98add9"}, "insert": "x"}, {"insert": ". "}, {"attributes": {"color": "#98add9"}, "insert": "O(1)"}, {"insert": "."}, {"attributes": {"list": "ordered"}, "insert": "\n"}, {"insert": "Union("}, {"attributes": {"color": "#98add9"}, "insert": "x"}, {"insert": ","}, {"attributes": {"color": "#98add9"}, "insert": "y"}, {"insert": "): Append the list containing "}, {"attributes": {"color": "#98add9"}, "insert": "y"}, {"insert": " to the list containing "}, {"attributes": {"color": "#98add9"}, "insert": "x"}, {"insert": ". Then update "}, {"attributes": {"color": "#50c75a"}, "insert": "head pointers"}, {"insert": ". "}, {"attributes": {"color": "#98add9"}, "insert": "O(|T|)"}, {"insert": ", where "}, {"attributes": {"color": "#98add9"}, "insert": "|T|"}, {"insert": " is the size of the list containing "}, {"attributes": {"color": "#98add9"}, "insert": "y"}, {"insert": "."}, {"attributes": {"list": "ordered"}, "insert": "\n"}, {"insert": "\nWe can do somewhat better with Union("}, {"attributes": {"color": "#98add9"}, "insert": "x"}, {"insert": ","}, {"attributes": {"color": "#98add9"}, "insert": "y"}, {"insert": ") by ensuring "}, {"attributes": {"color": "#98add9"}, "insert": "y"}, {"insert": " is the shorter list, by maintaining the "}, {"attributes": {"color": "#50c75a"}, "insert": "length "}, {"insert": "of each "}, {"attributes": {"color": "#47a1b3"}, "insert": "list "}, {"insert": "in its "}, {"attributes": {"color": "#50c75a"}, "insert": "head "}, {"attributes": {"color": "#edfaff"}, "insert": "- we call this the "}, {"attributes": {"color": "#47a1b3"}, "insert": "Weighted-Union heuristic"}, {"attributes": {"color": "#edfaff"}, "insert": "."}, {"insert": "\n\nDoing so, a sequence of "}, {"attributes": {"color": "#98add9"}, "insert": "m"}, {"insert": " operations on a structure with "}, {"attributes": {"color": "#98add9"}, "insert": "n"}, {"insert": " elements takes "}, {"attributes": {"color": "#98add9"}, "insert": "O(m + n log n)"}, {"insert": " time.\n\nWe prove this using the "}, {"attributes": {"link": "#Aggregate"}, "insert": "aggregate method"}, {"insert": ": each of Make-Set and Find-Set take only "}, {"attributes": {"color": "#98add9"}, "insert": "O(1)"}, {"insert": " time, so "}, {"attributes": {"color": "#98add9"}, "insert": "m "}, {"insert": "of these will take "}, {"attributes": {"color": "#98add9"}, "insert": "O(m)"}, {"insert": " time.\n\nFor Union, we only need the fact that the "}, {"attributes": {"color": "#50c75a"}, "insert": "head pointer"}, {"insert": " of any element "}, {"attributes": {"color": "#98add9"}, "insert": "x"}, {"insert": " is updated at most "}, {"attributes": {"color": "#98add9"}, "insert": "log n"}, {"insert": " times. Since the cost of a Union operation is "}, {"attributes": {"color": "#98add9"}, "insert": "O(# of head updates)"}, {"insert": ", this means the"}, {"attributes": {"color": "#98add9"}, "insert": " total cost "}, {"insert": "of these operations is "}, {"attributes": {"color": "#98add9"}, "insert": "O(n log n)"}, {"insert": ".\n\nWe prove this fact since we know that, as we link the "}, {"attributes": {"color": "#47a1b3"}, "insert": "head "}, {"insert": "of the "}, {"attributes": {"color": "#47a1b3"}, "insert": "shorter list"}, {"insert": " to the "}, {"attributes": {"color": "#47a1b3"}, "insert": "longer"}, {"insert": ", the "}, {"attributes": {"color": "#47a1b3"}, "insert": "shorter list"}, {"insert": "'s "}, {"attributes": {"color": "#50c75a"}, "insert": "length "}, {"insert": "grows by at least 2 for each Union operation. Since we have "}, {"attributes": {"color": "#98add9"}, "insert": "n"}, {"insert": " elements, the list can therefore grow at most"}, {"attributes": {"color": "#98add9"}, "insert": " log n"}, {"insert": " times.\n"}]}, "text": "Linked Lists for Disjoint Sets\n\nWe might use a linked list to implement a disjoint-set datastructure. We represent each set by a linked list, and store those linked lists in their own higher-level linked list. We keep pointers to the first and last elements of the list.\n\n\n\n\nWe implement the operations as follows:\n\n\n\n\nMake-Set(x): Append a singleton list x to the main list, and update pointers. O(1).\nFind-Set(x): Follow the head pointer until reaching x. O(1).\nUnion(x,y): Append the list containing y to the list containing x. Then update head pointers. O(|T|), where |T| is the size of the list containing y.\n\n\n\n\nWe can do somewhat better with Union(x,y) by ensuring y is the shorter list, by maintaining the length of each list in its head - we call this the Weighted-Union heuristic.\n\n\n\n\nDoing so, a sequence of m operations on a structure with n elements takes O(m + n log n) time.\n\n\n\n\nWe prove this using the aggregate method: each of Make-Set and Find-Set take only O(1) time, so m of these will take O(m) time.\n\n\n\n\nFor Union, we only need the fact that the head pointer of any element x is updated at most log n times. Since the cost of a Union operation is O(# of head updates), this means the total cost of these operations is O(n log n).\n\n\n\n\nWe prove this fact since we know that, as we link the head of the shorter list to the longer, the shorter list's length grows by at least 2 for each Union operation. Since we have n elements, the list can therefore grow at most log n times.", "updatedAt": 1714660659168}