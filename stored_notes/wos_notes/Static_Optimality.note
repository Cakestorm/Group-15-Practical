{"title": "Static Optimality", "body": {"ops": [{"attributes": {"color": "#47a1b3", "underline": true}, "insert": "Static Optimality"}, {"attributes": {"header": 2}, "insert": "\n"}, {"insert": "When operating on "}, {"attributes": {"link": "#Binary_Search_Trees"}, "insert": "binary search trees"}, {"insert": ", we care about how "}, {"attributes": {"color": "#47a1b3"}, "insert": "balanced "}, {"insert": "the tree is. When we say "}, {"attributes": {"color": "#47a1b3"}, "insert": "balanced"}, {"insert": ", we mean that the tree has a minimum or close-to-minimum "}, {"attributes": {"color": "#50c75a"}, "insert": "height "}, {"insert": "(as in, its "}, {"attributes": {"color": "#50c75a"}, "insert": "height "}, {"insert": "is "}, {"attributes": {"color": "#98add9"}, "insert": "O(log n)"}, {"insert": " ), or alternatively that each node generally has two children.\n\nTo demonstrate this, consider the "}, {"attributes": {"link": "#Binary_Search_Trees"}, "insert": "BST"}, {"insert": ", with "}, {"attributes": {"color": "#98add9"}, "insert": "n"}, {"insert": " nodes, with each node only having a left child. If we want to access the "}, {"attributes": {"color": "#50c75a"}, "insert": "least element"}, {"insert": " of this tree, we must access "}, {"attributes": {"color": "#98add9"}, "insert": "O(n)"}, {"insert": " nodes - "}, {"attributes": {"color": "#50c75a"}, "insert": "terrible"}, {"insert": ", for a data structure whose appeal is its "}, {"attributes": {"color": "#98add9"}, "insert": "O(log n)"}, {"insert": " access promise! We can do better.\n\nIn a "}, {"attributes": {"color": "#47a1b3"}, "insert": "balanced tree"}, {"insert": ", on the other hand, since its height is "}, {"attributes": {"color": "#98add9"}, "insert": "O(log n)"}, {"insert": ", we ensure that each access takes at most "}, {"attributes": {"color": "#98add9"}, "insert": "O(log n)"}, {"insert": " time.\n\nA "}, {"attributes": {"color": "#47a1b3"}, "insert": "statically optimal tree"}, {"insert": ", then, is a tree with the"}, {"attributes": {"color": "#50c75a"}, "insert": " least aggregate lookup cost"}, {"insert": " - it must be "}, {"attributes": {"color": "#47a1b3"}, "insert": "balanced"}, {"insert": "!\n\nThe problem in achieving this is that, if we "}, {"attributes": {"color": "#50c75a"}, "insert": "naively "}, {"insert": "insert elements into a "}, {"attributes": {"link": "#Binary_Search_Trees"}, "insert": "BST"}, {"insert": ", we may "}, {"attributes": {"color": "#47a1b3"}, "insert": "unbalance "}, {"insert": "the tree. To ameliorate this, we may consider the following datastructures, which whilst not perfectly balanced attempt to approximate "}, {"attributes": {"color": "#47a1b3"}, "insert": "static optimality"}, {"insert": ":\n\n"}, {"attributes": {"link": "#Red_Black_Trees"}, "insert": "Red-Black Trees"}, {"attributes": {"list": "ordered"}, "insert": "\n"}, {"attributes": {"link": "#Splay_Trees"}, "insert": "Splay Trees"}, {"attributes": {"list": "ordered"}, "insert": "\n"}, {"insert": "\nWhich both maintain a"}, {"attributes": {"color": "#47a1b3"}, "insert": " balanced tree"}, {"insert": " through their provided operations.\n"}]}, "text": "Static Optimality\n\nWhen operating on binary search trees, we care about how balanced the tree is. When we say balanced, we mean that the tree has a minimum or close-to-minimum height (as in, its height is O(log n) ), or alternatively that each node generally has two children.\n\n\n\n\nTo demonstrate this, consider the BST, with n nodes, with each node only having a left child. If we want to access the least element of this tree, we must access O(n) nodes - terrible, for a data structure whose appeal is its O(log n) access promise! We can do better.\n\n\n\n\nIn a balanced tree, on the other hand, since its height is O(log n), we ensure that each access takes at most O(log n) time.\n\n\n\n\nA statically optimal tree, then, is a tree with the least aggregate lookup cost - it must be balanced!\n\n\n\n\nThe problem in achieving this is that, if we naively insert elements into a BST, we may unbalance the tree. To ameliorate this, we may consider the following datastructures, which whilst not perfectly balanced attempt to approximate static optimality:\n\n\n\n\nRed-Black Trees\nSplay Trees\n\n\n\n\nWhich both maintain a balanced tree through their provided operations.", "updatedAt": 1714596335658, "embeddings": ["-0.57698506", "-0.47504783", "-0.35484225", "0.027702603", "-0.16653748", "-0.24609694", "-0.642315", "0.9092782", "1.0854586", "0.46966928", "1.2702854", "0.341883", "-1.2553953", "-0.6506369", "-1.9457712", "-0.48097935", "-0.9099184", "0.74932384", "0.9678007", "0.23712169", "0.43803257", "-0.41801938", "1.1461496", "1.060417", "0.078054376", "-0.96375877", "0.24867426", "0.44709596", "-0.1254299", "0.0017373896", "0.17676248", "-0.21811147", "1.1079428", "0.2232603", "0.14743868", "-1.0885651", "-0.82146806", "-0.6880825", "-0.23623055", "0.3358892", "-1.4833428", "-1.1054114", "-0.15682013", "-1.0204222", "1.0680658", "0.11789011", "-1.0176607", "1.4212414", "-0.68212503", "-0.76546425", "-0.003231791", "0.42284134", "0.5219182", "-0.5349", "0.6999966", "0.16679099", "1.2961084", "0.27865362", "0.36923754", "-0.5135212", "0.12265821", "0.9304665", "0.4051961", "-0.5686938", "-0.12132011", "0.1849724", "-0.66216797", "0.56758535", "0.016236749", "0.07998277", "1.1282811", "-1.1499317", "0.5805727", "0.026252815", "0.27336335", "0.83149374", "0.68018246", "-0.21825658", "-0.64314723", "-1.0279342", "-0.18308069", "0.052141644", "-0.53747797", "0.0070982557", "-1.1948391", "0.9422153", "0.20180514", "-0.9124956", "-1.1849561", "0.041594483", "-0.19910091", "0.9585485", "0.16158202", "0.12075336", "-0.015919961", "0.89119226", "-0.46969992", "-1.7611773", "-0.08339828", "1.8681079", "-0.29327992", "0.63958305", "1.4377893", "-0.74548274", "-0.50584215", "-0.7987917", "-0.6881396", "0.32144687", "-0.8086571", "-0.23643675", "-1.6478599", "-0.8620879", "2.3140514", "1.2172544", "1.2904434", "-0.17792155", "0.7122756", "-0.8802341", "1.2191656", "-1.821508", "1.4787865", "0.2223089", "0.19296108", "-0.1077785", "0.9314187", "-0.052506484", "0.66691697", "0.9708912", "0.7016254", "-0.9427919", "0.6905998", "-0.14638877", "-0.5547239", "1.119092", "-1.2710267", "-0.31866863", "-0.21021794", "-0.16229017", "-0.426343", "-0.7468138", "0.1645398", "-0.71183103", "-1.2952158", "-0.84745926", "-1.5620002", "-1.0957435", "0.23449315", "0.22416048", "-0.17258143", "-0.9245073", "-0.31007084", "-0.19799455", "-0.7114436", "0.1879555", "-0.30048147", "-1.1994171", "0.38509512", "0.32787794", "0.015162342", "-0.410757", "-0.52028674", "2.252093", "0.31969962", "-0.5894587", "-0.3050483", "0.054979727", "0.69033146", "0.23129864", "-0.9371012", "-1.2024674", "1.7838113", "-0.2200308", "-1.2145807", "0.33809566", "0.115194276", "0.5334244", "-0.06095989", "0.1174915", "0.7530096", "0.5719909", "-0.18598942", "0.3171579", "0.37373266", "0.18759476", "-0.48558277", "0.2533778", "-0.14144817", "1.244652", "2.1803536", "0.99040484", "-0.20098001", "0.47295287", "1.2609274", "0.7451483", "-0.6959816", "0.36360762", "0.05765914", "0.03308726", "-0.031730607", "1.0670475"]}