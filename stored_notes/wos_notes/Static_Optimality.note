{"title": "Static Optimality", "body": {"ops": [{"attributes": {"color": "#47a1b3", "underline": true}, "insert": "Static Optimality"}, {"attributes": {"header": 2}, "insert": "\n"}, {"insert": "When operating on "}, {"attributes": {"link": "#Binary_Search_Trees"}, "insert": "binary search trees"}, {"insert": ", we care about how "}, {"attributes": {"color": "#47a1b3"}, "insert": "balanced "}, {"insert": "the tree is. When we say "}, {"attributes": {"color": "#47a1b3"}, "insert": "balanced"}, {"insert": ", we mean that the tree has a minimum or close-to-minimum "}, {"attributes": {"color": "#50c75a"}, "insert": "height "}, {"insert": "(as in, its "}, {"attributes": {"color": "#50c75a"}, "insert": "height "}, {"insert": "is "}, {"attributes": {"color": "#98add9"}, "insert": "O(log n)"}, {"insert": " ), or alternatively that each node generally has two children.\n\nTo demonstrate this, consider the "}, {"attributes": {"link": "#Binary_Search_Trees"}, "insert": "BST"}, {"insert": ", with "}, {"attributes": {"color": "#98add9"}, "insert": "n"}, {"insert": " nodes, with each node only having a left child. If we want to access the "}, {"attributes": {"color": "#50c75a"}, "insert": "least element"}, {"insert": " of this tree, we must access "}, {"attributes": {"color": "#98add9"}, "insert": "O(n)"}, {"insert": " nodes - "}, {"attributes": {"color": "#50c75a"}, "insert": "terrible"}, {"insert": ", for a data structure whose appeal is its "}, {"attributes": {"color": "#98add9"}, "insert": "O(log n)"}, {"insert": " access promise! We can do better.\n\nIn a "}, {"attributes": {"color": "#47a1b3"}, "insert": "balanced tree"}, {"insert": ", on the other hand, since its height is "}, {"attributes": {"color": "#98add9"}, "insert": "O(log n)"}, {"insert": ", we ensure that each access takes at most "}, {"attributes": {"color": "#98add9"}, "insert": "O(log n)"}, {"insert": " time.\n\nA "}, {"attributes": {"color": "#47a1b3"}, "insert": "statically optimal tree"}, {"insert": ", then, is a tree with the"}, {"attributes": {"color": "#50c75a"}, "insert": " least aggregate lookup cost"}, {"insert": " - it must be "}, {"attributes": {"color": "#47a1b3"}, "insert": "balanced"}, {"insert": "!\n\nThe problem in achieving this is that, if we "}, {"attributes": {"color": "#50c75a"}, "insert": "naively "}, {"insert": "insert elements into a "}, {"attributes": {"link": "#Binary_Search_Trees"}, "insert": "BST"}, {"insert": ", we may "}, {"attributes": {"color": "#47a1b3"}, "insert": "unbalance "}, {"insert": "the tree. To ameliorate this, we may consider the following datastructures, which whilst not perfectly balanced attempt to approximate "}, {"attributes": {"color": "#47a1b3"}, "insert": "static optimality"}, {"insert": ":\n\n"}, {"attributes": {"link": "#Red_Black_Trees"}, "insert": "Red-Black Trees"}, {"attributes": {"list": "ordered"}, "insert": "\n"}, {"attributes": {"link": "#Splay_Trees"}, "insert": "Splay Trees"}, {"attributes": {"list": "ordered"}, "insert": "\n"}, {"insert": "\nWhich both maintain a"}, {"attributes": {"color": "#47a1b3"}, "insert": " balanced tree"}, {"insert": " through their provided operations.\n"}]}, "text": "Static Optimality\n\nWhen operating on binary search trees, we care about how balanced the tree is. When we say balanced, we mean that the tree has a minimum or close-to-minimum height (as in, its height is O(log n) ), or alternatively that each node generally has two children.\n\n\n\n\nTo demonstrate this, consider the BST, with n nodes, with each node only having a left child. If we want to access the least element of this tree, we must access O(n) nodes - terrible, for a data structure whose appeal is its O(log n) access promise! We can do better.\n\n\n\n\nIn a balanced tree, on the other hand, since its height is O(log n), we ensure that each access takes at most O(log n) time.\n\n\n\n\nA statically optimal tree, then, is a tree with the least aggregate lookup cost - it must be balanced!\n\n\n\n\nThe problem in achieving this is that, if we naively insert elements into a BST, we may unbalance the tree. To ameliorate this, we may consider the following datastructures, which whilst not perfectly balanced attempt to approximate static optimality:\n\n\n\n\nRed-Black Trees\nSplay Trees\n\n\n\n\nWhich both maintain a balanced tree through their provided operations.", "updatedAt": 1714596335658, "embeddings": ["1.2310582", "-0.6077469", "0.05568818", "-0.28702828", "-0.4722365", "-0.14249565", "0.62060565", "1.1860218", "0.5359763", "-1.0202962", "-0.2547992", "-0.89534664", "0.190109", "0.16997911", "-1.0757962", "0.5961706", "1.8467785", "-0.047621995", "0.33299315", "0.34730512", "0.72488886", "-0.06594129", "0.30998096", "0.18692167", "-1.4199902", "1.4684689", "0.24369755", "0.6299988", "0.9618131", "-0.9279524", "1.2382383", "0.6500066", "0.5739686", "-0.6231579", "-0.6861357", "-0.88609964", "-0.8841726", "0.65800524", "-1.0607859", "0.6433839", "-0.6327147", "0.79156387", "-0.6955809", "-0.4798482", "0.90274966", "-1.2014682", "0.36352217", "-1.2589105", "-0.17591566", "-0.816967", "-0.3251334", "-0.52292484", "1.4420613", "-1.029313", "-0.28339285", "-0.7355799", "-0.031561144", "-0.15390262", "-1.0310012", "0.20150861", "0.9514314", "-0.2055173", "0.80214596", "-0.7906438", "0.67949986", "0.19789855", "0.46238518", "1.4463594", "-0.804378", "0.31867483", "-0.40761575", "-0.9189945", "0.045518287", "0.52889407", "0.18594521", "0.6429941", "-0.59375143", "-1.8398606", "0.6079831", "-0.05546675", "-0.23391324", "-0.040981937", "-1.097907", "0.5308821", "-1.6491735", "0.22509538", "-0.11910652", "0.63035893", "-0.2733358", "0.6619206", "1.0632553", "0.4399411", "1.0705949", "0.8777119", "0.033039987", "0.34116834", "0.5613542", "0.65857595", "-0.56739366", "0.98618597", "-0.35891047", "0.909424", "-0.16842356", "-0.13180114", "0.56184703", "-0.6247842", "0.8757387", "-0.9395023", "0.2947739", "-1.1968075", "0.53793126", "-1.1889372", "-0.36378142", "-0.0792112", "-0.8959909", "-0.50055987", "-0.7583977", "-1.705292", "0.10875203", "0.08751896", "-0.736843", "0.49806836", "0.28366885", "0.09419561", "0.5568129", "1.3300159", "0.63665885", "-0.22653094", "-0.7377179", "-0.19135468", "0.121972956", "0.3217321", "0.604409", "1.0553998", "0.7965088", "1.342807", "0.02688331", "-0.410591", "1.6923798", "-0.117827445", "1.2118676", "-0.76506406", "-1.1528", "-0.63171977", "-1.6639835", "-0.5909544", "-1.022373", "0.3328947", "0.06354792", "-0.57254565", "1.0480498", "-0.18600315", "-0.5878124", "-0.86368454", "-0.47768968", "-0.017361008", "0.38941982", "0.14880264", "-0.5257329", "0.13849954", "-0.38844413", "-0.6363229", "-0.15501504", "0.23297636", "0.13333361", "1.500663", "-0.28017396", "-0.47089702", "0.4529506", "-0.37370208", "0.30171856", "0.9899209", "-0.15423377", "-0.22477533", "1.1616608", "-0.12583138", "-0.3142898", "0.26307836", "0.14767295", "1.105657", "-0.21057074", "0.8452607", "0.44137594", "0.11664022", "0.06892449", "0.06641837", "-0.24334477", "0.4983787", "1.9128697", "0.88037795", "-0.83802754", "-2.0597708", "-0.8620932", "-1.3220127", "-0.40788913", "0.5281629", "0.5291588", "-2.3476164", "0.20279868", "-0.38692355"]}