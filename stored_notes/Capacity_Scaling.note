{"title": "Capacity-Scaling Algorithm", "body": {"ops": [{"attributes": {"color": "#47a1b3", "underline": true}, "insert": "Capacity-Scaling Algorithm"}, {"attributes": {"header": 2}, "insert": "\n"}, {"insert": "The"}, {"attributes": {"color": "#47a1b3"}, "insert": " capacity-scaling algorithm"}, {"insert": " is a"}, {"attributes": {"link": "http://127.0.0.1:5000/#822d800b-7ce9-496b-8533-66c684217958"}, "insert": " max flow algorithm"}, {"insert": " with a runtime of"}, {"attributes": {"color": "#98add9"}, "insert": " O(m"}, {"attributes": {"color": "#98add9"}, "insert": {"formula": "^2"}}, {"attributes": {"color": "#98add9"}, "insert": " (1 + log C))"}, {"attributes": {"color": "#edfaff"}, "insert": "."}, {"insert": "\n\nLet's give the algorithm below:\n"}, {"attributes": {"header": 2}, "insert": "\n"}, {"insert": "Capacity-Scaling:"}, {"attributes": {"header": 2}, "insert": "\n"}, {"insert": "  "}, {"attributes": {"color": "#98add9"}, "insert": "C"}, {"insert": " <- maxmimum edge capacity;\n "}, {"attributes": {"color": "#98add9"}, "insert": {"formula": "\\Delta"}}, {"attributes": {"color": "#98add9"}, "insert": " "}, {"insert": "<- least power of 2 less than "}, {"attributes": {"color": "#98add9"}, "insert": "C"}, {"insert": ";\n "}, {"attributes": {"color": "#50c75a"}, "insert": "while"}, {"insert": "("}, {"attributes": {"color": "#98add9"}, "insert": {"formula": "\\Delta"}}, {"insert": " "}, {"insert": {"formula": "\\geq"}}, {"insert": "  "}, {"attributes": {"color": "#98add9"}, "insert": "1"}, {"insert": "){\n    "}, {"attributes": {"color": "#50c75a"}, "insert": "while"}, {"insert": "("}, {"attributes": {"color": "#98add9"}, "insert": {"formula": "\\exists"}}, {"attributes": {"color": "#98add9"}, "insert": " s-t"}, {"insert": " path "}, {"attributes": {"color": "#98add9"}, "insert": "P"}, {"insert": " in "}, {"attributes": {"color": "#98add9"}, "insert": {"formula": "G_f(\\Delta)"}}, {"insert": " ){\n      "}, {"attributes": {"link": "#c55dfae1-ca34-4e91-a8c1-d926712ab1b4"}, "insert": "Augment"}, {"insert": "("}, {"attributes": {"color": "#98add9"}, "insert": "P"}, {"insert": ");\n      "}, {"attributes": {"color": "#47a1b3"}, "insert": "Update"}, {"insert": "("}, {"attributes": {"color": "#98add9"}, "insert": {"formula": "G_f(\\Delta)"}}, {"insert": "); \n    }\n  "}, {"attributes": {"color": "#98add9"}, "insert": {"formula": "\\Delta"}}, {"insert": " <- "}, {"attributes": {"color": "#98add9"}, "insert": {"formula": "\\Delta"}}, {"attributes": {"color": "#98add9"}, "insert": " /2"}, {"insert": "\n }\nreturn "}, {"attributes": {"color": "#98add9"}, "insert": "f"}, {"insert": "\n\nWhere "}, {"attributes": {"color": "#98add9"}, "insert": {"formula": "G_f(\\Delta)"}}, {"insert": " is the residual graph"}, {"attributes": {"color": "#98add9"}, "insert": " "}, {"attributes": {"color": "#98add9"}, "insert": {"formula": "G_f"}}, {"insert": " with all edge capacities greater than"}, {"attributes": {"color": "#98add9"}, "insert": " "}, {"attributes": {"color": "#98add9"}, "insert": {"formula": "\\Delta"}}, {"insert": ".\n\nLet's consider some results of this "}, {"attributes": {"color": "#47a1b3"}, "insert": "algorithm"}, {"insert": ".\n\nThe "}, {"attributes": {"color": "#47a1b3"}, "insert": "key result"}, {"insert": " is that, at the end of each "}, {"attributes": {"color": "#47a1b3"}, "insert": {"formula": "\\Delta"}}, {"attributes": {"color": "#47a1b3"}, "insert": "-scaling cycle"}, {"insert": ", Then"}, {"attributes": {"color": "#98add9"}, "insert": " "}, {"attributes": {"color": "#98add9"}, "insert": {"formula": "|f*| \\leq |f| + m\\Delta"}}, {"insert": " .\n\nWe prove as follows: At the end of a "}, {"attributes": {"color": "#47a1b3"}, "insert": {"formula": "\\Delta"}}, {"attributes": {"color": "#47a1b3"}, "insert": "-scaling cycle"}, {"insert": ", consider the set of vertices A reachable from s in"}, {"attributes": {"color": "#98add9"}, "insert": " "}, {"attributes": {"color": "#98add9"}, "insert": {"formula": "G_f(\\Delta)"}}, {"insert": ". Now, in"}, {"attributes": {"color": "#98add9"}, "insert": " "}, {"attributes": {"color": "#98add9"}, "insert": {"formula": "G_f"}}, {"insert": " , the capacity of each edge (a,b) with "}, {"attributes": {"color": "#98add9"}, "insert": {"formula": "a \\in A"}}, {"attributes": {"color": "#98add9"}, "insert": " "}, {"insert": "and"}, {"attributes": {"color": "#98add9"}, "insert": " "}, {"attributes": {"color": "#98add9"}, "insert": {"formula": "b \\in V \\setminus A"}}, {"attributes": {"color": "#98add9"}, "insert": "  "}, {"insert": "must be less than "}, {"attributes": {"color": "#98add9"}, "insert": {"formula": "\\Delta"}}, {"insert": "; were it not then b would be reachable in "}, {"attributes": {"color": "#98add9"}, "insert": {"formula": "G_f(\\Delta)"}}, {"insert": " . \n\nHence, the maxmimum capacity of the cut would be at most "}, {"insert": {"formula": "m \\Delta"}}, {"insert": ". And since we may consider (A, V\\A) a cut, by weak duality"}, {"attributes": {"color": "#98add9"}, "insert": " |f*| "}, {"attributes": {"color": "#98add9"}, "insert": {"formula": "\\leq"}}, {"attributes": {"color": "#98add9"}, "insert": " Cap(A, V\\A) "}, {"attributes": {"color": "#98add9"}, "insert": {"formula": "\\leq"}}, {"attributes": {"color": "#98add9"}, "insert": " "}, {"attributes": {"color": "#98add9"}, "insert": {"formula": "m\\Delta"}}, {"insert": " . So it follows that "}, {"attributes": {"color": "#98add9"}, "insert": {"formula": "|f*| \\leq |f| + m\\Delta"}}, {"attributes": {"color": "#98add9"}, "insert": " "}, {"insert": ".\n\nAs a "}, {"attributes": {"color": "#98add9"}, "insert": "corollary"}, {"insert": ", it follows that the inner loop is executed at most"}, {"attributes": {"color": "#98add9"}, "insert": " m "}, {"insert": "times for any"}, {"attributes": {"color": "#47a1b3"}, "insert": " "}, {"attributes": {"color": "#47a1b3"}, "insert": {"formula": "\\Delta"}}, {"insert": ".\n\n\n"}]}, "text": "Capacity-Scaling Algorithm\n\nThe capacity-scaling algorithm is a max flow algorithm with a runtime of O(m\ufeff\n2\n2\n\ufeff (1 + log C)).\n\n\n\n\nLet's give the algorithm below:\n\n\n\nCapacity-Scaling:\n\n  C <- maxmimum edge capacity;\n\n \ufeff\n\u0394\n\u0394\ufeff <- least power of 2 less than C;\n\n while(\ufeff\n\u0394\n\u0394\ufeff \ufeff\n\u2265\n\u2265\ufeff  1){\n\n    while(\ufeff\n\u2203\n\u2203\ufeff s-t path P in \ufeff\nGf(\u0394)\nG\nf\n\t\u200b\n\n(\u0394)\ufeff ){\n\n      Augment(P);\n\n      Update(\ufeff\nGf(\u0394)\nG\nf\n\t\u200b\n\n(\u0394)\ufeff); \n\n    }\n\n  \ufeff\n\u0394\n\u0394\ufeff <- \ufeff\n\u0394\n\u0394\ufeff /2\n\n }\n\nreturn f\n\n\n\n\nWhere \ufeff\nGf(\u0394)\nG\nf\n\t\u200b\n\n(\u0394)\ufeff is the residual graph \ufeff\nGf\nG\nf\n\t\u200b\n\n\ufeff with all edge capacities greater than \ufeff\n\u0394\n\u0394\ufeff.\n\n\n\n\nLet's consider some results of this algorithm.\n\n\n\n\nThe key result is that, at the end of each \ufeff\n\u0394\n\u0394\ufeff-scaling cycle, Then \ufeff\n\u2223f\u2217\u2223\u2264\u2223f\u2223+m\u0394\n\u2223f\u2217\u2223\u2264\u2223f\u2223+m\u0394\ufeff .\n\n\n\n\nWe prove as follows: At the end of a \ufeff\n\u0394\n\u0394\ufeff-scaling cycle, consider the set of vertices A reachable from s in \ufeff\nGf(\u0394)\nG\nf\n\t\u200b\n\n(\u0394)\ufeff. Now, in \ufeff\nGf\nG\nf\n\t\u200b\n\n\ufeff , the capacity of each edge (a,b) with \ufeff\na\u2208A\na\u2208A\ufeff and \ufeff\nb\u2208V\u2216A\nb\u2208V\u2216A\ufeff  must be less than \ufeff\n\u0394\n\u0394\ufeff; were it not then b would be reachable in \ufeff\nGf(\u0394)\nG\nf\n\t\u200b\n\n(\u0394)\ufeff . \n\n\n\n\nHence, the maxmimum capacity of the cut would be at most \ufeff\nm\u0394\nm\u0394\ufeff. And since we may consider (A, V\\A) a cut, by weak duality |f*| \ufeff\n\u2264\n\u2264\ufeff Cap(A, V\\A) \ufeff\n\u2264\n\u2264\ufeff \ufeff\nm\u0394\nm\u0394\ufeff . So it follows that \ufeff\n\u2223f\u2217\u2223\u2264\u2223f\u2223+m\u0394\n\u2223f\u2217\u2223\u2264\u2223f\u2223+m\u0394\ufeff .\n\n\n\n\nAs a corollary, it follows that the inner loop is executed at most m times for any \ufeff\n\u0394\n\u0394\ufeff.\n\n\n\n\n\n", "updatedAt": 1714749319738}