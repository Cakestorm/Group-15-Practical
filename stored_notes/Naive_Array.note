{"title": "Array Implementation for Disjoint Sets", "body": {"ops": [{"attributes": {"alt": "STRUCTURAL ELEMENTS: Heading level 2"}, "insert": {"image": "moz-extension://8e7074b9-66b6-424e-b54b-c19b7851ffab/img/icons/h2.svg"}}, {"attributes": {"color": "#47a1b3", "underline": true}, "insert": "Array Implementation for Disjoint Sets"}, {"attributes": {"alt": "ALERTS: Underlined text", "color": "#47a1b3", "underline": true}, "insert": {"image": "moz-extension://8e7074b9-66b6-424e-b54b-c19b7851ffab/img/icons/underline.svg"}}, {"attributes": {"header": 2}, "insert": "\n"}, {"insert": "A basic way of maintaining a "}, {"attributes": {"link": "#Disjoint_Sets"}, "insert": "disjoint-set datastructure"}, {"attributes": {"alt": "ALERTS: Broken same-page link", "link": "#Disjoint_Sets"}, "insert": {"image": "moz-extension://8e7074b9-66b6-424e-b54b-c19b7851ffab/img/icons/link_internal_broken.svg"}}, {"insert": ". \n\nSuppose the elements we are storing are in the range [1..n]. We maintain an array R of representatives, where R[i] is the representative of i, and define the operations on the datastructure as:\n\nMake-Set(x): Set R[x] = x. This is O(1)."}, {"attributes": {"list": "ordered"}, "insert": "\n"}, {"insert": "Find-Set(x): Return the value of R[x]. This is O(1)."}, {"attributes": {"list": "ordered"}, "insert": "\n"}, {"insert": "Union(x,y): For each element i of R, if R[i] = x, then set R[i] = y. This is O(n) (!!)"}, {"attributes": {"list": "ordered"}, "insert": "\n"}, {"insert": "\nWe are not a fan of the O(n) Union(x,y) operation. We can do better. In particular, we might want to consider:\n\n"}, {"attributes": {"link": "#Linked_List_Implementation"}, "insert": "Linked list implementations"}, {"attributes": {"alt": "ALERTS: Broken same-page link", "link": "#Linked_List_Implementation"}, "insert": {"image": "moz-extension://8e7074b9-66b6-424e-b54b-c19b7851ffab/img/icons/link_internal_broken.svg"}}, {"attributes": {"list": "ordered"}, "insert": "\n"}, {"insert": "Disjoint Forests"}, {"attributes": {"list": "ordered"}, "insert": "\n"}]}, "text": "Array Implementation for Disjoint Sets\n\nA basic way of maintaining a disjoint-set datastructure. \n\n\n\n\nSuppose the elements we are storing are in the range [1..n]. We maintain an array R of representatives, where R[i] is the representative of i, and define the operations on the datastructure as:\n\n\n\n\nMake-Set(x): Set R[x] = x. This is O(1).\nFind-Set(x): Return the value of R[x]. This is O(1).\nUnion(x,y): For each element i of R, if R[i] = x, then set R[i] = y. This is O(n) (!!)\n\n\n\n\nWe are not a fan of the O(n) Union(x,y) operation. We can do better. In particular, we might want to consider:\n\n\n\n\nLinked list implementations\nDisjoint Forests", "updatedAt": 1714698636280}