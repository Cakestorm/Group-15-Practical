{"title": "Implementation for Disjoint Sets", "body": {"ops": [{"attributes": {"color": "#47a1b3", "underline": true}, "insert": "Implementation for Disjoint Sets"}, {"attributes": {"header": 2}, "insert": "\n"}, {"insert": "A basic way of maintaining a "}, {"attributes": {"link": "#Disjoint_Sets"}, "insert": "disjoint-set datastructure"}, {"insert": ". \n\nSuppose the elements we are storing are in the range [1..n]. We maintain an array R of representatives, where R[i] is the representative of i, and define the operations on the datastructure as:\n\nMake-Set(x): Set R[x] = x. This is O(1)."}, {"attributes": {"list": "ordered"}, "insert": "\n"}, {"insert": "Find-Set(x): Return the value of R[x]. This is O(1)."}, {"attributes": {"list": "ordered"}, "insert": "\n"}, {"insert": "Union(x,y): For each element i of R, if R[i] = x, then set R[i] = y. This is O(n) (!!)"}, {"attributes": {"list": "ordered"}, "insert": "\n"}, {"insert": "\nWe are not a fan of the O(n) Union(x,y) operation. We can do better. In particular, we might want to consider:\n\n"}, {"attributes": {"link": "#Linked_List_Implementation"}, "insert": "Linked list implementations"}, {"attributes": {"list": "ordered"}, "insert": "\n"}, {"insert": "Disjoint Forests"}, {"attributes": {"list": "ordered"}, "insert": "\n"}]}, "text": "Implementation for Disjoint Sets\n\nA basic way of maintaining a disjoint-set datastructure. \n\n\n\n\nSuppose the elements we are storing are in the range [1..n]. We maintain an array R of representatives, where R[i] is the representative of i, and define the operations on the datastructure as:\n\n\n\n\nMake-Set(x): Set R[x] = x. This is O(1).\nFind-Set(x): Return the value of R[x]. This is O(1).\nUnion(x,y): For each element i of R, if R[i] = x, then set R[i] = y. This is O(n) (!!)\n\n\n\n\nWe are not a fan of the O(n) Union(x,y) operation. We can do better. In particular, we might want to consider:\n\n\n\n\nLinked list implementations\nDisjoint Forests", "updatedAt": 1715164053766}