{"title": "Array Implementation for Disjoint Sets", "body": {"ops": [{"attributes": {"color": "#47a1b3", "underline": true}, "insert": "Array Implementation for Disjoint Sets"}, {"attributes": {"header": 2}, "insert": "\n"}, {"insert": "A basic way of maintaining a "}, {"attributes": {"link": "#Disjoint_Sets"}, "insert": "disjoint-set datastructure"}, {"insert": ". \n\nSuppose the elements we are storing are in the range "}, {"attributes": {"color": "#98add9"}, "insert": "[1..n]"}, {"insert": ". We maintain an array "}, {"attributes": {"color": "#98add9"}, "insert": "R"}, {"insert": " of "}, {"attributes": {"color": "#50c75a"}, "insert": "representatives"}, {"insert": ", where "}, {"attributes": {"color": "#98add9"}, "insert": "R[i]"}, {"insert": " is the "}, {"attributes": {"color": "#50c75a"}, "insert": "representative "}, {"insert": "of i, and define the operations on the datastructure as:\n\nMake-Set("}, {"attributes": {"color": "#98add9"}, "insert": "x"}, {"insert": "): Set "}, {"attributes": {"color": "#98add9"}, "insert": "R[x] = x"}, {"insert": ". This is "}, {"attributes": {"color": "#98add9"}, "insert": "O(1)"}, {"insert": "."}, {"attributes": {"list": "ordered"}, "insert": "\n"}, {"insert": "Find-Set("}, {"attributes": {"color": "#98add9"}, "insert": "x"}, {"insert": "): Return the value of "}, {"attributes": {"color": "#98add9"}, "insert": "R[x]"}, {"insert": ". This is "}, {"attributes": {"color": "#98add9"}, "insert": "O(1)"}, {"insert": "."}, {"attributes": {"list": "ordered"}, "insert": "\n"}, {"insert": "Union("}, {"attributes": {"color": "#98add9"}, "insert": "x"}, {"insert": ","}, {"attributes": {"color": "#98add9"}, "insert": "y"}, {"insert": "): For each element "}, {"attributes": {"color": "#98add9"}, "insert": "i"}, {"insert": " of "}, {"attributes": {"color": "#98add9"}, "insert": "R"}, {"insert": ", if "}, {"attributes": {"color": "#98add9"}, "insert": "R[i] = x"}, {"insert": ", then set "}, {"attributes": {"color": "#98add9"}, "insert": "R[i] = y"}, {"insert": ". This is "}, {"attributes": {"color": "#47a1b3"}, "insert": "O(n)"}, {"insert": " "}, {"attributes": {"color": "#50c75a"}, "insert": "(!!)"}, {"attributes": {"list": "ordered"}, "insert": "\n"}, {"insert": "\nWe are not a fan of the "}, {"attributes": {"color": "#98add9"}, "insert": "O(n)"}, {"insert": " Union("}, {"attributes": {"color": "#98add9"}, "insert": "x"}, {"insert": ","}, {"attributes": {"color": "#98add9"}, "insert": "y"}, {"insert": ") operation. We can do better. In particular, we might want to consider:\n\n"}, {"attributes": {"link": "#Linked_List_Implementation"}, "insert": "Linked list implementations"}, {"attributes": {"list": "ordered"}, "insert": "\n"}, {"insert": "Disjoint Forests"}, {"attributes": {"list": "ordered"}, "insert": "\n"}]}, "text": "Array Implementation for Disjoint Sets\n\nA basic way of maintaining a disjoint-set datastructure. \n\n\n\n\nSuppose the elements we are storing are in the range [1..n]. We maintain an array R of representatives, where R[i] is the representative of i, and define the operations on the datastructure as:\n\n\n\n\nMake-Set(x): Set R[x] = x. This is O(1).\nFind-Set(x): Return the value of R[x]. This is O(1).\nUnion(x,y): For each element i of R, if R[i] = x, then set R[i] = y. This is O(n) (!!)\n\n\n\n\nWe are not a fan of the O(n) Union(x,y) operation. We can do better. In particular, we might want to consider:\n\n\n\n\nLinked list implementations\nDisjoint Forests", "updatedAt": 1714599688095}