{"title": "Static Optimality", "body": {"ops": [{"attributes": {"color": "#47a1b3", "underline": true}, "insert": "Static Optimality"}, {"attributes": {"header": 2}, "insert": "\n"}, {"insert": "When operating on "}, {"attributes": {"link": "#Binary_Search_Trees"}, "insert": "binary search trees"}, {"insert": ", we care about how "}, {"attributes": {"color": "#47a1b3"}, "insert": "balanced "}, {"insert": "the tree is. When we say "}, {"attributes": {"color": "#47a1b3"}, "insert": "balanced"}, {"insert": ", we mean that the tree has a minimum or close-to-minimum "}, {"attributes": {"color": "#50c75a"}, "insert": "height "}, {"insert": "(as in, its "}, {"attributes": {"color": "#50c75a"}, "insert": "height "}, {"insert": "is "}, {"attributes": {"color": "#98add9"}, "insert": "O(log n)"}, {"insert": " ), or alternatively that each node generally has two children.\n\nTo demonstrate this, consider the "}, {"attributes": {"link": "#Binary_Search_Trees"}, "insert": "BST"}, {"insert": ", with "}, {"attributes": {"color": "#98add9"}, "insert": "n"}, {"insert": " nodes, with each node only having a left child. If we want to access the "}, {"attributes": {"color": "#50c75a"}, "insert": "least element"}, {"insert": " of this tree, we must access "}, {"attributes": {"color": "#98add9"}, "insert": "O(n)"}, {"insert": " nodes - "}, {"attributes": {"color": "#50c75a"}, "insert": "terrible"}, {"insert": ", for a data structure whose appeal is its "}, {"attributes": {"color": "#98add9"}, "insert": "O(log n)"}, {"insert": " access promise! We can do better.\n\nIn a "}, {"attributes": {"color": "#47a1b3"}, "insert": "balanced tree"}, {"insert": ", on the other hand, since its height is "}, {"attributes": {"color": "#98add9"}, "insert": "O(log n)"}, {"insert": ", we ensure that each access takes at most "}, {"attributes": {"color": "#98add9"}, "insert": "O(log n)"}, {"insert": " time.\n\nA "}, {"attributes": {"color": "#47a1b3"}, "insert": "statically optimal tree"}, {"insert": ", then, is a tree with the"}, {"attributes": {"color": "#50c75a"}, "insert": " least aggregate lookup cost"}, {"insert": " - it must be "}, {"attributes": {"color": "#47a1b3"}, "insert": "balanced"}, {"insert": "!\n\nThe problem in achieving this is that, if we "}, {"attributes": {"color": "#50c75a"}, "insert": "naively "}, {"insert": "insert elements into a "}, {"attributes": {"link": "#Binary_Search_Trees"}, "insert": "BST"}, {"insert": ", we may "}, {"attributes": {"color": "#47a1b3"}, "insert": "unbalance "}, {"insert": "the tree. To ameliorate this, we may consider the following datastructures, which whilst not perfectly balanced attempt to approximate "}, {"attributes": {"color": "#47a1b3"}, "insert": "static optimality"}, {"insert": ":\n\n"}, {"attributes": {"link": "#Red_Black_Trees"}, "insert": "Red-Black Trees"}, {"attributes": {"list": "ordered"}, "insert": "\n"}, {"attributes": {"link": "#Splay_Trees"}, "insert": "Splay Trees"}, {"attributes": {"list": "ordered"}, "insert": "\n"}, {"insert": "\nWhich both maintain a"}, {"attributes": {"color": "#47a1b3"}, "insert": " balanced tree"}, {"insert": " through their provided operations.\n"}]}, "text": "Static Optimality\n\nWhen operating on binary search trees, we care about how balanced the tree is. When we say balanced, we mean that the tree has a minimum or close-to-minimum height (as in, its height is O(log n) ), or alternatively that each node generally has two children.\n\n\n\n\nTo demonstrate this, consider the BST, with n nodes, with each node only having a left child. If we want to access the least element of this tree, we must access O(n) nodes - terrible, for a data structure whose appeal is its O(log n) access promise! We can do better.\n\n\n\n\nIn a balanced tree, on the other hand, since its height is O(log n), we ensure that each access takes at most O(log n) time.\n\n\n\n\nA statically optimal tree, then, is a tree with the least aggregate lookup cost - it must be balanced!\n\n\n\n\nThe problem in achieving this is that, if we naively insert elements into a BST, we may unbalance the tree. To ameliorate this, we may consider the following datastructures, which whilst not perfectly balanced attempt to approximate static optimality:\n\n\n\n\nRed-Black Trees\nSplay Trees\n\n\n\n\nWhich both maintain a balanced tree through their provided operations.", "updatedAt": 1714596335658}