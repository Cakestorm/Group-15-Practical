{"title": "Static Optimality", "body": {"ops": [{"attributes": {"color": "#47a1b3", "underline": true}, "insert": "Static Optimality"}, {"attributes": {"header": 2}, "insert": "\n"}, {"insert": "When operating on "}, {"attributes": {"link": "#Binary_Search_Trees"}, "insert": "binary search trees"}, {"insert": ", we care about how "}, {"attributes": {"color": "#47a1b3"}, "insert": "balanced "}, {"insert": "the tree is. When we say "}, {"attributes": {"color": "#47a1b3"}, "insert": "balanced"}, {"insert": ", we mean that the tree has a minimum or close-to-minimum "}, {"attributes": {"color": "#50c75a"}, "insert": "height "}, {"insert": "(as in, its "}, {"attributes": {"color": "#50c75a"}, "insert": "height "}, {"insert": "is "}, {"attributes": {"color": "#98add9"}, "insert": "O(log n)"}, {"insert": " ), or alternatively that each node generally has two children.\n\nTo demonstrate this, consider the "}, {"attributes": {"link": "#Binary_Search_Trees"}, "insert": "BST"}, {"insert": ", with "}, {"attributes": {"color": "#98add9"}, "insert": "n"}, {"insert": " nodes, with each node only having a left child. If we want to access the "}, {"attributes": {"color": "#50c75a"}, "insert": "least element"}, {"insert": " of this tree, we must access "}, {"attributes": {"color": "#98add9"}, "insert": "O(n)"}, {"insert": " nodes - "}, {"attributes": {"color": "#50c75a"}, "insert": "terrible"}, {"insert": ", for a data structure whose appeal is its "}, {"attributes": {"color": "#98add9"}, "insert": "O(log n)"}, {"insert": " access promise! We can do better.\n\nIn a "}, {"attributes": {"color": "#47a1b3"}, "insert": "balanced tree"}, {"insert": ", on the other hand, since its height is "}, {"attributes": {"color": "#98add9"}, "insert": "O(log n)"}, {"insert": ", we ensure that each access takes at most "}, {"attributes": {"color": "#98add9"}, "insert": "O(log n)"}, {"insert": " time.\n\nA "}, {"attributes": {"color": "#47a1b3"}, "insert": "statically optimal tree"}, {"insert": ", then, is a tree with the"}, {"attributes": {"color": "#50c75a"}, "insert": " least aggregate lookup cost"}, {"insert": " - it must be "}, {"attributes": {"color": "#47a1b3"}, "insert": "balanced"}, {"insert": "!\n\nThe problem in achieving this is that, if we "}, {"attributes": {"color": "#50c75a"}, "insert": "naively "}, {"insert": "insert elements into a "}, {"attributes": {"link": "#Binary_Search_Trees"}, "insert": "BST"}, {"insert": ", we may "}, {"attributes": {"color": "#47a1b3"}, "insert": "unbalance "}, {"insert": "the tree. To ameliorate this, we may consider the following datastructures, which whilst not perfectly balanced attempt to approximate "}, {"attributes": {"color": "#47a1b3"}, "insert": "static optimality"}, {"insert": ":\n\n"}, {"attributes": {"link": "#Red_Black_Trees"}, "insert": "Red-Black Trees"}, {"attributes": {"list": "ordered"}, "insert": "\n"}, {"attributes": {"link": "#Splay_Trees"}, "insert": "Splay Trees"}, {"attributes": {"list": "ordered"}, "insert": "\n"}, {"insert": "\nWhich both maintain a"}, {"attributes": {"color": "#47a1b3"}, "insert": " balanced tree"}, {"insert": " through their provided operations.\n"}]}, "text": "Static Optimality\n\nWhen operating on binary search trees, we care about how balanced the tree is. When we say balanced, we mean that the tree has a minimum or close-to-minimum height (as in, its height is O(log n) ), or alternatively that each node generally has two children.\n\n\n\n\nTo demonstrate this, consider the BST, with n nodes, with each node only having a left child. If we want to access the least element of this tree, we must access O(n) nodes - terrible, for a data structure whose appeal is its O(log n) access promise! We can do better.\n\n\n\n\nIn a balanced tree, on the other hand, since its height is O(log n), we ensure that each access takes at most O(log n) time.\n\n\n\n\nA statically optimal tree, then, is a tree with the least aggregate lookup cost - it must be balanced!\n\n\n\n\nThe problem in achieving this is that, if we naively insert elements into a BST, we may unbalance the tree. To ameliorate this, we may consider the following datastructures, which whilst not perfectly balanced attempt to approximate static optimality:\n\n\n\n\nRed-Black Trees\nSplay Trees\n\n\n\n\nWhich both maintain a balanced tree through their provided operations.", "updatedAt": 1714596335658, "embeddings": ["-1.0425776", "0.04768615", "1.5133345", "0.15842831", "1.3980459", "1.2196698", "-3.2136953", "0.2293222", "-1.8003991", "-0.50103843", "1.4113058", "-0.69575423", "-1.4957958", "-2.5315354", "2.0306501", "-1.1947967", "0.05575827", "-1.0764002", "-1.2901429", "0.57503235", "-0.7445511", "-0.07961926", "0.77127826", "1.3922825", "-2.3521936", "3.1774302", "-0.26872444", "-2.5445724", "-1.7646832", "-0.79792064", "-3.336033", "-1.0064559", "1.7141793", "0.70640194", "-2.7321293", "-1.3059655", "0.4705277", "-0.3948152", "-1.1666266", "-1.7134768", "-1.164418", "0.6104915", "-2.6181424", "-0.66124034", "-0.029006787", "1.4327223", "0.99905974", "2.3702645", "0.44671538", "1.1192349", "1.7001895", "0.07915138", "1.708931", "-0.040529568", "0.65082496", "0.79173416", "1.4397765", "0.36993927", "0.4895506", "-0.057934467", "-1.2152104", "4.3008037", "-0.22746815", "-0.13006838", "-0.8938678", "1.3588264", "-0.63872176", "1.5117105", "1.4269022", "0.31740987", "-1.7973024", "-1.1259792", "-0.07230284", "1.4489515", "-0.8604964", "0.15059914", "0.78804606", "1.2451757", "-1.3608999", "-1.7911038", "-1.5731434", "-0.21156174", "1.0306288", "-0.023330558", "0.9477167", "2.454219", "0.3711934", "-0.1634593", "-2.159862", "0.41945955", "0.87919575", "-1.4443709", "0.5440978", "2.4272697", "0.47273162", "1.3219975", "-1.4418895", "0.5055101", "0.17094043", "-2.3810523", "-2.1594334", "-0.5192979", "-2.2715256", "-1.8212425", "-0.85690284", "-0.046277717", "-2.1768742", "0.78014", "3.420301", "-0.31154707", "-1.6655045", "-0.1339479", "-0.9173941", "0.42702958", "0.98576975", "0.14017746", "1.2902321", "-1.2991475", "2.057353", "1.9707892", "1.4189448", "1.3900347", "-0.3173578", "0.320248", "-0.5648008", "-2.1468947", "-2.440732", "0.7005947", "1.593401", "0.5609965", "-0.26938716", "1.9149365", "0.40942836", "-0.1771224", "0.6965239", "-0.5810965", "0.7241138", "-0.17721136", "0.5758797", "1.888738", "-0.40730855", "0.9586443", "-0.30865225", "-0.652686", "-2.4177904", "2.0406268", "0.5458588", "0.7392389", "1.3426443", "0.7531748", "0.33029965", "1.100863", "-2.0032568", "-0.9648162", "-1.6547225", "0.4371431", "2.072513", "-0.9020325", "0.03529355", "0.485297", "0.07961609", "1.4687229", "0.33078843", "-1.5944514", "-1.227854", "1.9161967", "1.1528748", "-0.15218543", "1.3109182", "1.6687089", "2.8181696", "-0.20463085", "0.21710952", "1.5362412", "2.4796007", "2.6268175", "-2.034843", "1.2191653", "2.13109", "-2.7822185", "1.8373475", "-0.7217759", "1.960857", "-0.68962294", "-0.43382058", "0.31482288", "-0.9315006", "-0.64198864", "1.8792616", "0.15943438", "2.1881325", "-1.3960735", "-0.092209056", "1.1185488", "0.4741079", "0.22066182", "1.933501", "-0.31781796", "-0.7093666", "-0.07664197"]}