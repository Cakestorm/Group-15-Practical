{"title": "Static Optimality", "body": {"ops": [{"attributes": {"color": "#47a1b3", "underline": true}, "insert": "Static Optimality"}, {"attributes": {"header": 2}, "insert": "\n"}, {"insert": "When operating on "}, {"attributes": {"link": "#Binary_Search_Trees"}, "insert": "binary search trees"}, {"insert": ", we care about how "}, {"attributes": {"color": "#47a1b3"}, "insert": "balanced "}, {"insert": "the tree is. When we say "}, {"attributes": {"color": "#47a1b3"}, "insert": "balanced"}, {"insert": ", we mean that the tree has a minimum or close-to-minimum "}, {"attributes": {"color": "#50c75a"}, "insert": "height "}, {"insert": "(as in, its "}, {"attributes": {"color": "#50c75a"}, "insert": "height "}, {"insert": "is "}, {"attributes": {"color": "#98add9"}, "insert": "O(log n)"}, {"insert": " ), or alternatively that each node generally has two children.\n\nTo demonstrate this, consider the "}, {"attributes": {"link": "#Binary_Search_Trees"}, "insert": "BST"}, {"insert": ", with "}, {"attributes": {"color": "#98add9"}, "insert": "n"}, {"insert": " nodes, with each node only having a left child. If we want to access the "}, {"attributes": {"color": "#50c75a"}, "insert": "least element"}, {"insert": " of this tree, we must access "}, {"attributes": {"color": "#98add9"}, "insert": "O(n)"}, {"insert": " nodes - "}, {"attributes": {"color": "#50c75a"}, "insert": "terrible"}, {"insert": ", for a data structure whose appeal is its "}, {"attributes": {"color": "#98add9"}, "insert": "O(log n)"}, {"insert": " access promise! We can do better.\n\nIn a "}, {"attributes": {"color": "#47a1b3"}, "insert": "balanced tree"}, {"insert": ", on the other hand, since its height is "}, {"attributes": {"color": "#98add9"}, "insert": "O(log n)"}, {"insert": ", we ensure that each access takes at most "}, {"attributes": {"color": "#98add9"}, "insert": "O(log n)"}, {"insert": " time.\n\nA "}, {"attributes": {"color": "#47a1b3"}, "insert": "statically optimal tree"}, {"insert": ", then, is a tree with the"}, {"attributes": {"color": "#50c75a"}, "insert": " least aggregate lookup cost"}, {"insert": " - it must be "}, {"attributes": {"color": "#47a1b3"}, "insert": "balanced"}, {"insert": "!\n\nThe problem in achieving this is that, if we "}, {"attributes": {"color": "#50c75a"}, "insert": "naively "}, {"insert": "insert elements into a "}, {"attributes": {"link": "#Binary_Search_Trees"}, "insert": "BST"}, {"insert": ", we may "}, {"attributes": {"color": "#47a1b3"}, "insert": "unbalance "}, {"insert": "the tree. To ameliorate this, we may consider the following datastructures, which whilst not perfectly balanced attempt to approximate "}, {"attributes": {"color": "#47a1b3"}, "insert": "static optimality"}, {"insert": ":\n\n"}, {"attributes": {"link": "#Red_Black_Trees"}, "insert": "Red-Black Trees"}, {"attributes": {"list": "ordered"}, "insert": "\n"}, {"attributes": {"link": "#Splay_Trees"}, "insert": "Splay Trees"}, {"attributes": {"list": "ordered"}, "insert": "\n"}, {"insert": "\nWhich both maintain a"}, {"attributes": {"color": "#47a1b3"}, "insert": " balanced tree"}, {"insert": " through their provided operations.\n"}]}, "text": "Static Optimality\n\nWhen operating on binary search trees, we care about how balanced the tree is. When we say balanced, we mean that the tree has a minimum or close-to-minimum height (as in, its height is O(log n) ), or alternatively that each node generally has two children.\n\n\n\n\nTo demonstrate this, consider the BST, with n nodes, with each node only having a left child. If we want to access the least element of this tree, we must access O(n) nodes - terrible, for a data structure whose appeal is its O(log n) access promise! We can do better.\n\n\n\n\nIn a balanced tree, on the other hand, since its height is O(log n), we ensure that each access takes at most O(log n) time.\n\n\n\n\nA statically optimal tree, then, is a tree with the least aggregate lookup cost - it must be balanced!\n\n\n\n\nThe problem in achieving this is that, if we naively insert elements into a BST, we may unbalance the tree. To ameliorate this, we may consider the following datastructures, which whilst not perfectly balanced attempt to approximate static optimality:\n\n\n\n\nRed-Black Trees\nSplay Trees\n\n\n\n\nWhich both maintain a balanced tree through their provided operations.", "updatedAt": 1714596335658, "embeddings": ["-0.87278724", "0.3119826", "1.3359292", "0.2662138", "1.1176064", "1.0792034", "-3.0422802", "0.023463255", "-1.6697974", "-0.7890356", "1.248808", "-0.815583", "-1.0626837", "-2.4034216", "2.130561", "-0.91341937", "-0.03384468", "-0.9993446", "-1.0851653", "0.9025991", "-0.82379574", "0.060910378", "0.6807726", "1.4535002", "-2.3045137", "3.4489987", "-0.17638952", "-2.097921", "-1.5360178", "-0.78489536", "-3.1015933", "-1.1710534", "1.775661", "0.6034389", "-3.0016866", "-1.4473011", "0.44113597", "-0.4213894", "-0.85723615", "-1.4192355", "-1.0016639", "0.8161401", "-2.3690968", "-0.9281559", "0.128018", "1.6293496", "0.656653", "2.6258457", "0.6519007", "0.8640329", "1.5019896", "-0.022230972", "1.463898", "0.23265728", "0.6832985", "0.30530405", "1.413425", "0.49552274", "0.41523626", "-0.02059915", "-1.1565963", "4.1580772", "-0.33365333", "0.33140743", "-0.57955873", "1.3136613", "-0.82698286", "1.8025866", "1.0327462", "0.34868273", "-2.1197882", "-1.3189692", "-0.36435828", "1.4300903", "-0.8262711", "-0.20260908", "0.91401625", "1.109558", "-1.5793887", "-1.6029878", "-1.5954425", "-0.23349543", "0.6762462", "0.114065565", "0.7142604", "2.4900868", "0.19447361", "-0.06942554", "-2.1284704", "0.707802", "1.0113994", "-1.4779251", "0.25248462", "2.2630365", "0.43347698", "1.4031028", "-1.6252736", "0.30086967", "0.2746974", "-2.2179434", "-2.1734626", "-0.6022121", "-2.476427", "-1.7936314", "-1.2460728", "-0.31600103", "-2.3134897", "1.4795433", "3.4074392", "-0.2151973", "-1.4207394", "-0.5018191", "-1.1382291", "0.121168815", "0.95800436", "0.00092700135", "1.5919231", "-1.3624171", "1.8515899", "1.915089", "1.357768", "1.1467125", "-0.6485862", "0.112889685", "-0.35535127", "-1.9445058", "-2.327474", "0.39338657", "2.0608783", "0.7683908", "-0.31385493", "1.7610337", "0.3430495", "-0.19445817", "0.86535305", "-0.665259", "0.61550087", "-0.11659562", "0.60874605", "2.042998", "-0.5944536", "1.0102873", "-0.38597816", "-0.6446568", "-2.7648807", "1.829846", "0.52110565", "0.6737792", "1.1605576", "0.6602897", "0.5821772", "1.0600913", "-2.0402915", "-1.0693309", "-1.1937131", "0.18919776", "2.2590067", "-0.8822781", "0.26356992", "1.0407751", "0.6328656", "1.5209086", "0.16439305", "-1.5051386", "-1.2765386", "1.9841638", "1.34547", "0.20534393", "1.3070643", "1.542356", "3.0620244", "-0.11338216", "0.45884618", "1.5456868", "2.2166362", "2.655094", "-1.625447", "1.668177", "2.254358", "-2.5210607", "2.1947079", "-0.9074752", "2.0368478", "-0.9421147", "-0.5964797", "0.43343857", "-0.8460133", "-0.4735839", "1.8401856", "0.076829985", "2.6471202", "-1.5387477", "-0.2055149", "1.5231901", "0.5431311", "0.31867838", "2.0628328", "-0.34831774", "-0.54553896", "-0.033660643"]}